/* automatically generated by rust-bindgen 0.71.1 */

pub const CPUSTRING: &[u8; 7] = b"x86_64\0";
pub const BUILD_STRING: &[u8; 13] = b"linux-x86_64\0";
pub const PATHSEPARATOR_STR: &[u8; 2] = b"/\0";
pub const PATHSEPARATOR_CHAR: u8 = 47u8;
pub const NEWLINE: &[u8; 2] = b"\n\0";
pub const PRIiSIZE: &[u8; 3] = b"zi\0";
pub const PRIuSIZE: &[u8; 3] = b"zu\0";
pub const PRIxSIZE: &[u8; 3] = b"zx\0";
pub const MAX_STRING_CHARS: u32 = 1024;
pub const MAX_PRINT_MSG: u32 = 16384;
pub const MAX_WORLD_COORD: u32 = 131072;
pub const MIN_WORLD_COORD: i32 = -131072;
pub const MAX_WORLD_SIZE: u32 = 262144;
pub const CONST_PI: f64 = 3.141592653589793;
unsafe extern "C" {
    pub static mut ignoredReturnValue: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_Z12AssertFailedPKciS0_"]
    pub fn AssertFailed(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        expression: *const ::std::os::raw::c_char,
    ) -> bool;
}
pub type byte = ::std::os::raw::c_uchar;
pub type word = ::std::os::raw::c_ushort;
pub type dword = ::std::os::raw::c_uint;
pub type uint = ::std::os::raw::c_uint;
pub type ulong = ::std::os::raw::c_ulong;
pub type int8 = ::std::os::raw::c_schar;
pub type uint8 = ::std::os::raw::c_uchar;
pub type int16 = ::std::os::raw::c_short;
pub type uint16 = ::std::os::raw::c_ushort;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type int64 = ::std::os::raw::c_longlong;
pub type uint64 = ::std::os::raw::c_ulonglong;
pub type compile_time_assert_typedef_43 = u8;
pub type compile_time_assert_typedef_44 = u8;
pub type compile_time_assert_typedef_45 = u8;
pub type compile_time_assert_typedef_46 = u8;
pub type compile_time_assert_typedef_47 = u8;
pub type compile_time_assert_typedef_48 = u8;
pub type compile_time_assert_typedef_49 = u8;
pub type compile_time_assert_typedef_50 = u8;
pub type compile_time_assert_typedef_51 = u8;
pub type compile_time_assert_typedef_52 = u8;
pub type compile_time_assert_typedef_53 = u8;
pub type compile_time_assert_typedef_54 = u8;
pub type compile_time_assert_typedef_55 = u8;
pub type compile_time_assert_typedef_56 = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idFile {
    _unused: [u8; 0],
}
pub const MAX_ENTITY_COORDINATE: f32 = 64000.0;
pub type triIndex_t = ::std::os::raw::c_uint;
#[doc = "The Dark Mod GPL Source Code\n\nThis file is part of the The Dark Mod Source Code, originally based\non the Doom 3 GPL Source Code as published in 2011.\n\nThe Dark Mod Source Code is free software: you can redistribute it\nand/or modify it under the terms of the GNU General Public License as\npublished by the Free Software Foundation, either version 3 of the License,\nor (at your option) any later version. For details, see LICENSE.TXT.\n\nProject: The Dark Mod (http://www.thedarkmod.com/)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idVec2 {
    pub x: f32,
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of idVec2"][::std::mem::size_of::<idVec2>() - 8usize];
    ["Alignment of idVec2"][::std::mem::align_of::<idVec2>() - 4usize];
    ["Offset of field: idVec2::x"][::std::mem::offset_of!(idVec2, x) - 0usize];
    ["Offset of field: idVec2::y"][::std::mem::offset_of!(idVec2, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idVec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of idVec3"][::std::mem::size_of::<idVec3>() - 12usize];
    ["Alignment of idVec3"][::std::mem::align_of::<idVec3>() - 4usize];
    ["Offset of field: idVec3::x"][::std::mem::offset_of!(idVec3, x) - 0usize];
    ["Offset of field: idVec3::y"][::std::mem::offset_of!(idVec3, y) - 4usize];
    ["Offset of field: idVec3::z"][::std::mem::offset_of!(idVec3, z) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct idVec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of idVec4"][::std::mem::size_of::<idVec4>() - 16usize];
    ["Alignment of idVec4"][::std::mem::align_of::<idVec4>() - 4usize];
    ["Offset of field: idVec4::x"][::std::mem::offset_of!(idVec4, x) - 0usize];
    ["Offset of field: idVec4::y"][::std::mem::offset_of!(idVec4, y) - 4usize];
    ["Offset of field: idVec4::z"][::std::mem::offset_of!(idVec4, z) - 8usize];
    ["Offset of field: idVec4::w"][::std::mem::offset_of!(idVec4, w) - 12usize];
};
pub type confirmLoad_t = ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type loadPCMFromMemory_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        num_channels: ::std::os::raw::c_int,
        bits_per_sample: ::std::os::raw::c_int,
        num_samples_per_sec: ::std::os::raw::c_int,
        objectSize: ::std::os::raw::c_int,
        objectMemSize: ::std::os::raw::c_int,
        subtitleDecl: *const ::std::os::raw::c_char,
        _nonCacheData: *mut byte,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct returnCallbacks_t {
    pub returnString:
        ::std::option::Option<unsafe extern "C" fn(text: *const ::std::os::raw::c_char)>,
    pub returnFloat: ::std::option::Option<unsafe extern "C" fn(value: f32)>,
    pub returnInt: ::std::option::Option<unsafe extern "C" fn(value: ::std::os::raw::c_int)>,
    pub returnVector: ::std::option::Option<unsafe extern "C" fn(vec: *const idVec3)>,
    pub returnBytes: ::std::option::Option<unsafe extern "C" fn(text: *mut ::std::os::raw::c_char)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of returnCallbacks_t"][::std::mem::size_of::<returnCallbacks_t>() - 40usize];
    ["Alignment of returnCallbacks_t"][::std::mem::align_of::<returnCallbacks_t>() - 8usize];
    ["Offset of field: returnCallbacks_t::returnString"]
        [::std::mem::offset_of!(returnCallbacks_t, returnString) - 0usize];
    ["Offset of field: returnCallbacks_t::returnFloat"]
        [::std::mem::offset_of!(returnCallbacks_t, returnFloat) - 8usize];
    ["Offset of field: returnCallbacks_t::returnInt"]
        [::std::mem::offset_of!(returnCallbacks_t, returnInt) - 16usize];
    ["Offset of field: returnCallbacks_t::returnVector"]
        [::std::mem::offset_of!(returnCallbacks_t, returnVector) - 24usize];
    ["Offset of field: returnCallbacks_t::returnBytes"]
        [::std::mem::offset_of!(returnCallbacks_t, returnBytes) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LibraryABI {
    pub confirmLoad: confirmLoad_t,
    pub returnCallbacks: returnCallbacks_t,
    pub loadPCMFromMemory: loadPCMFromMemory_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of LibraryABI"][::std::mem::size_of::<LibraryABI>() - 56usize];
    ["Alignment of LibraryABI"][::std::mem::align_of::<LibraryABI>() - 8usize];
    ["Offset of field: LibraryABI::confirmLoad"]
        [::std::mem::offset_of!(LibraryABI, confirmLoad) - 0usize];
    ["Offset of field: LibraryABI::returnCallbacks"]
        [::std::mem::offset_of!(LibraryABI, returnCallbacks) - 8usize];
    ["Offset of field: LibraryABI::loadPCMFromMemory"]
        [::std::mem::offset_of!(LibraryABI, loadPCMFromMemory) - 48usize];
};
