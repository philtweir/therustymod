# The Rusty Mod

Demonstrator toolkit for extending The Dark Mod's idTech4 scripting engine with Rust
shared libraries.

There is no Getting Started yet, as this is still pretty rough code, and
should be explored only if you are knowing what you are getting into!

In particular, TRM add-ons allow the other modders to hook into these functions. If
the depended-on module is not present on TDM launch, there will be an error
saying that the functions were requested but not loaded.

## Use

Start with the examples. A single `.so` file is generated by compiling the Rust
and will have the name `target/release/libMYRUSTMODULENAME.so`, for example,
`libtherustymod_web.so`. Note that it may not be the same as your TDM module
name. The below assumes you are running the PoC custom `extern`-enabled version
of TDM.

1. Start a new Rust library project and add this crate, `lazy_static`, `tokio`, `ctor`
    and `vtable-rs` to it (it should be possible to re-export from this crate,
    but I tried briefly and it did not seem to work, so for now just add them)
1. In your `lib.rs` file, create a `mod` with the name of your TDM module, let's
    say `mod_web_dashboard`
1. Add your new functions to the module
1. Add the `#[therustymod_lib(daemon=false)]` annotation to the module
1. If you wish to have an always-running thread (e.g. for a language server or
    web server), set `daemon=true` instead and add an `async fn __run()` function
    that will get called on TDM startup and stay running through out. It is
    being executed in Tokio and will get a `100ms` warning it is being shut down,
    assuming shutdown is happening gracefully. _All other functions should exit
    as fast as possible_ and offload any processing that should not hold up
    the game script to this thread (e.g. by `lazy_static` and synchronization
    primitives, perhaps with poll functions for a TDM script to check if
    long-running results are ready)
1. Create a new TDM add-on with a `/scripts` folder
1. Create a script header file, in the style of a C++ header, that starts with
    `#library "libMYRUSTMODULENAME.so"` as the first tokens. It should have an
    `extern mod_web_dashboard { ... }`, or similar, block that contains the
    script function declarations matching your Rust functions. Put both together
    in the `/script` folder and bundle as normal into a `.pk4`
1. If TDM can see the `.pk4`, then you _should_ now see your module load when you start
1. If your module is intended for use by other modders, try adding a second
   add-on, and in any scope (e.g. script/namespace) that you wish to use the
   compiled functions, add an `extern mod_web_dashboard { ... }` block with exactly the
   function definitions that you are looking for. You should be able to call them elsewhere
   in that code as if `extern` was a normal `namespace`. TDM will error out on
   start if those functions were not found at load time.

## Motivating ideas

Anything that would require functionality outside the scripting engine
but is never going to be desirable in the engine itself, especially if
the complexity is high and calling frequency low (less than once per frame).

Some would require changes to the idTech4 engine, e.g. extra general-purpose events, that
I have not PoC'd and go beyond the Library/extern code.

* Play real chess against a chess engine, in-game
* Use speech-to-text to converse with NPCs
* Generate dialogue via text-to-speech
* Use LLMs to increase variety of background chat
* Get data from internet, filesystem, etc.
* Call out to big maze-finding algorithms, etc. for AIs
* (Infrequently) re-rendering textures dynamically for e.g. SVG assets
* Doing some big map-reduce thing with a whole bunch of in-world location, etc. data
* Web dashboard for your add-on

Putting a few of those with the very cool The Dark Mod VR sounds like a pretty
amazing immersive experience.

## Limitations

* **Currently only works with G++ on Linux (and only tested on x86)**, although
  that _could_ be a case of tidying up some DLL code in `Library.cpp` and making
  sure there are no surprises in the C++-ABI workaround for dynamic loading from
  Rust shared libraries with MSVC, etc.
* Not tried with anything except sending and receiving very basic types, and not
  entities, etc. which will require additional implementation on the Rust side
* Right now, I do not have DLLs/sos running from the module script virtual filesystem
  so **they do need to be explicitly copied to the game folder**
* Putting a big binary black-box blob on the side has a bunch of obvious issues
  that do not need expanded: security, stability, crypto-miners, etc. -- at the
  very least, this is AGPL, which includes networked games, so do not 
* Calls to events defined here are slower than internal event calls, which these
  masquerade as, and likely slower than calling script functions. However, execution
  of the body should be as fast as Rust can optimize it, so you likely want infrequent
  calls for complex behaviour, not many maths calls per frame
* Dynamically extending the idTech4 events at run-time, with actual not script events,
  is not intended behaviour and may have unintended consequences, particularly if you
  add enough to hit internal limits
* Unholy sacrilege is committed to convince Rust that there should be a C++-compatible
  vtable so that idTech4, which _requires_ an idClass for all statically-defined events,
  (and these are pretending to be such), can think it's passing a pointer, while
  we continue pretending these are normal Rust functions
* For a bunch of reasons, it makes sense to group the 
* Rust is not really supposed to have all these static mutable objects about the place,
  even with Mutexes, but I struggled to think of a cleaner way to do it, that did not
  encourage shared state between events, which is a bad thing because...
* idTech4 has not planned around a big bunch of memory it does not know about _and_ has
  (currently) no way of saving/restoring, although it would be pretty easy to add hooks
  into Rust for this, if inserting black-bock blobs into savegames was really desirable
* idTech4 does not expect new `eventMaps` to pop up at runtime - there is a workaround
  but there may be unexpected implications, given how tight it manages memory
* A _whole_ bunch of tidy-up is needed in the extern implementation for idTech4

## Examples

* `mod_web_browser`: starts a [rocket](https://rocket.rs/) server on port 9797 that will
  log calls to the Rust functions from TDM scripts
